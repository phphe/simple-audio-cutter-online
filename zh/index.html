<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘è£å‰ªå™¨-ä¸ä¼šä¸Šä¼ ä½ çš„æ–‡ä»¶</title>
    <script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.31/vue.global.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@6.6.4/dist/wavesurfer.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@6.6.4/dist/plugin/wavesurfer.regions.min.js"></script>
    <!-- åˆ é™¤ 7.0.0 ç‰ˆæœ¬çš„å¼•ç”¨ï¼Œå› ä¸ºä¸ 6.6.4 ç‰ˆæœ¬ä¸å…¼å®¹ -->
    <script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/wavesurfer.js/7.0.0/plugins/regions.min.js"></script>
    <style>
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .drop-zone {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
        }

        .drop-zone.dragover {
            background-color: #e1e1e1;
            border-color: #999;
        }

        .waveform {
            margin: 20px 0;
        }

        .controls {
            margin: 20px 0;
        }

        button {
            margin: 0 10px;
            padding: 8px 16px;
        }

        .time-info {
            margin: 10px 0;
        }

        .status-message {
            margin: 10px 0;
            color: #4F4A85;
            font-weight: bold;
        }
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V3W9G1EGL5"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-V3W9G1EGL5');
    </script>
</head>

<body>
    <div id="app">
        <div class="container">
            <div class="privacy-notice"
                style="background-color: #e8f5e9; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                <p style="margin: 0; color: #2e7d32;">
                    âœ‚ï¸ è¿™æ˜¯ä¸€ä¸ªç®€å•çš„åœ¨çº¿éŸ³é¢‘è£å‰ªå·¥å…·ï¼Œå¯ä»¥å¿«é€Ÿå‰ªåˆ‡ä½ çš„éŸ³é¢‘æ–‡ä»¶ã€‚
                    <br>
                    ğŸ“¢ éšç§è¯´æ˜ï¼šæ‚¨çš„éŸ³é¢‘æ–‡ä»¶ä»…åœ¨æµè§ˆå™¨å†…å¤„ç†ï¼Œä¸ä¼šä¸Šä¼ åˆ°ä»»ä½•æœåŠ¡å™¨ã€‚
                    <br>
                    âš ï¸ æµè§ˆå™¨è¦æ±‚ï¼šè¯·ä½¿ç”¨ Chromeã€Firefoxã€Edge ç­‰ç°ä»£æµè§ˆå™¨ï¼Œéœ€è¦æ”¯æŒ Web Audio APIã€‚
                </p>
            </div>
            <div class="drop-zone" @dragover.prevent @drop.prevent="handleDrop" @dragenter="dragover = true"
                @dragleave="dragover = false" :class="{ dragover }" @click="triggerFileInput">
                ç‚¹å‡»æˆ–æ‹–æ”¾éŸ³é¢‘æ–‡ä»¶åˆ°è¿™é‡Œ
                <input type="file" ref="fileInput" style="display: none" @change="handleFileSelect" accept="audio/*">
            </div>
            <div id="waveform" class="waveform"></div>
            <div class="time-info" v-if="duration">
                å¼€å§‹æ—¶é—´: {{ formatTime(startTime) }} - ç»“æŸæ—¶é—´: {{ formatTime(endTime) }}
                <br>
                æ€»æ—¶é•¿: {{ formatTime(duration) }}
            </div>
            <div class="controls" style="display: flex; align-items: center; justify-content: space-between;">
                <div>
                    <button @click="playPause">æ’­æ”¾/æš‚åœ</button>
                    <button @click="trim">è£å‰ª</button>
                    <button @click="downloadAudio">ä¸‹è½½</button>
                </div>
                <div style="color: #2e7d32;">
                    <a href="/zh/" style="color: #2e7d32; text-decoration: none;">ä¸­æ–‡</a> /
                    <a href="/" style="color: #2e7d32; text-decoration: none;">English</a>
                </div>
            </div>
            <div v-if="trimStatus" class="status-message">{{ trimStatus }}</div>
        </div>
    </div>

    <script>
        const { createApp } = Vue

        createApp({
            data() {
                return {
                    wavesurfer: null,
                    dragover: false,
                    audioFile: null,
                    startTime: 0,
                    endTime: 0,
                    duration: 0,
                    trimmedBlob: null,
                    trimStatus: '' // æ·»åŠ çŠ¶æ€æç¤ºæ–‡æœ¬
                }
            },
            mounted() {
                this.initWaveSurfer()
            },
            methods: {
                initWaveSurfer() {
                    this.wavesurfer = WaveSurfer.create({
                        container: '#waveform',
                        waveColor: '#4F4A85',
                        progressColor: '#383351',
                        plugins: [
                            WaveSurfer.regions.create({
                                dragSelection: true,
                                slop: 5, // å¢åŠ å¯æ‹–åŠ¨åŒºåŸŸçš„å¤§å°
                                handleStyle: {
                                    left: {
                                        width: '8px',  // å¢åŠ å·¦ä¾§è¾¹æ¡†å®½åº¦
                                        backgroundColor: 'rgba(0, 123, 255, 0.5)'  // æ·»åŠ åŠé€æ˜èƒŒæ™¯è‰²
                                    },
                                    right: {
                                        width: '8px',  // å¢åŠ å³ä¾§è¾¹æ¡†å®½åº¦
                                        backgroundColor: 'rgba(0, 123, 255, 0.5)'  // æ·»åŠ åŠé€æ˜èƒŒæ™¯è‰²
                                    }
                                }
                            })
                        ]
                    })
                    this.wavesurfer.on('ready', () => {
                        this.duration = this.wavesurfer.getDuration()
                        this.endTime = this.duration
                        this.wavesurfer.addRegion({
                            start: 0,
                            end: this.duration,
                            drag: true,
                            resize: true,
                            color: 'rgba(0, 123, 255, 0.1)',
                            handleStyle: {      // è‡ªå®šä¹‰è¾¹æ¡†æ‰‹æŸ„æ ·å¼
                                left: {
                                    width: '8px',
                                    backgroundColor: 'rgba(0, 123, 255, 0.5)'
                                },
                                right: {
                                    width: '8px',
                                    backgroundColor: 'rgba(0, 123, 255, 0.5)'
                                }
                            }
                        })
                    })

                    this.wavesurfer.on('region-updated', region => {
                        this.startTime = region.start
                        this.endTime = region.end
                    })
                },
                triggerFileInput() {
                    this.$refs.fileInput.click()
                },
                handleFileSelect(event) {
                    const file = event.target.files[0]
                    if (file) {
                        this.loadAudioFile(file)
                    }
                },
                handleDrop(event) {
                    this.dragover = false
                    const file = event.dataTransfer.files[0]
                    if (file && file.type.startsWith('audio/')) {
                        this.loadAudioFile(file)
                    }
                },
                loadAudioFile(file) {
                    this.audioFile = file
                    this.wavesurfer.loadBlob(file)
                },
                playPause() {
                    this.wavesurfer.playPause()
                },
                async trim() {
                    if (!this.audioFile) {
                        alert('è¯·å…ˆåŠ è½½éŸ³é¢‘ï¼')
                        return
                    }
                    const audioContext = new AudioContext()
                    const response = await fetch(URL.createObjectURL(this.audioFile))
                    const arrayBuffer = await response.arrayBuffer()
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer)

                    const sampleRate = audioBuffer.sampleRate
                    const channels = audioBuffer.numberOfChannels
                    const startOffset = Math.floor(this.startTime * sampleRate)
                    const endOffset = Math.floor(this.endTime * sampleRate)
                    const frameCount = endOffset - startOffset

                    const trimmedBuffer = audioContext.createBuffer(channels, frameCount, sampleRate)
                    for (let channel = 0; channel < channels; channel++) {
                        const channelData = audioBuffer.getChannelData(channel)
                        const trimmedData = trimmedBuffer.getChannelData(channel)
                        for (let i = 0; i < frameCount; i++) {
                            trimmedData[i] = channelData[startOffset + i]
                        }
                    }
                    const trimmedAudio = this.audioBufferToWav(trimmedBuffer)
                    this.trimmedBlob = new Blob([trimmedAudio], { type: 'audio/wav' })
                    this.trimStatus = 'è£å‰ªå®Œæˆï¼å¯ä»¥ç‚¹å‡»ä¸‹è½½æŒ‰é’®ä¸‹è½½éŸ³é¢‘'
                },
                downloadAudio() {
                    if (!this.trimmedBlob) {
                        alert('è¯·å…ˆè£å‰ªéŸ³é¢‘ï¼')
                        return
                    }
                    const url = URL.createObjectURL(this.trimmedBlob)
                    const a = document.createElement('a')
                    a.href = url
                    a.download = 'trimmed_audio.wav'
                    document.body.appendChild(a)
                    a.click()
                    document.body.removeChild(a)
                    URL.revokeObjectURL(url)
                },
                audioBufferToWav(audioBuffer) {
                    // ç›´æ¥åœ¨è¿™é‡Œå®ç°éŸ³é¢‘æ•°æ®çš„äº¤ç»‡ï¼Œä¸å†è°ƒç”¨å•ç‹¬çš„æ–¹æ³•
                    const channels = audioBuffer.numberOfChannels
                    const length = audioBuffer.length * channels
                    const interleaved = new Float32Array(length)

                    for (let i = 0; i < audioBuffer.length; i++) {
                        for (let channel = 0; channel < channels; channel++) {
                            interleaved[i * channels + channel] = audioBuffer.getChannelData(channel)[i]
                        }
                    }

                    // å°† Float32Array è½¬æ¢ä¸º Int16Array
                    const samples = new Int16Array(interleaved.length)
                    for (let i = 0; i < interleaved.length; i++) {
                        const s = Math.max(-1, Math.min(1, interleaved[i]))
                        samples[i] = s < 0 ? s * 0x8000 : s * 0x7FFF
                    }
                    const dataView = this.createWavHeader(interleaved.length, audioBuffer.sampleRate)
                    return new Blob([dataView, samples.buffer], { type: 'audio/wav' })
                },
                // åˆ é™¤åŸæ¥çš„ interleave æ–¹æ³•
                createWavHeader(samples, sampleRate) {
                    const buffer = new ArrayBuffer(44)
                    const view = new DataView(buffer)

                    const writeString = (view, offset, string) => {
                        for (let i = 0; i < string.length; i++) {
                            view.setUint8(offset + i, string.charCodeAt(i))
                        }
                    }

                    const channels = 2 // æ”¹å›åŒå£°é“
                    const bytesPerSample = 2 // 16ä½é‡‡æ ·
                    const blockAlign = channels * bytesPerSample
                    const byteRate = sampleRate * blockAlign
                    const dataSize = samples * bytesPerSample // å®é™…æ•°æ®å¤§å°

                    writeString(view, 0, 'RIFF')
                    view.setUint32(4, 36 + dataSize, true) // æ–‡ä»¶æ€»å¤§å°
                    writeString(view, 8, 'WAVE')
                    writeString(view, 12, 'fmt ')
                    view.setUint32(16, 16, true)
                    view.setUint16(20, 1, true)
                    view.setUint16(22, channels, true)
                    view.setUint32(24, sampleRate, true)
                    view.setUint32(28, byteRate, true)
                    view.setUint16(32, blockAlign, true)
                    view.setUint16(34, 16, true)
                    writeString(view, 36, 'data')
                    view.setUint32(40, dataSize, true) // æ•°æ®å—å¤§å°

                    return buffer
                },
                formatTime(time) {
                    if (!time && time !== 0) return '0:00'
                    const minutes = Math.floor(time / 60)
                    const seconds = Math.floor(time % 60)
                    return `${minutes}:${seconds.toString().padStart(2, '0')}`
                },
            }
        }).mount('#app')
    </script>
</body>

</html>